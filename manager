#!/bin/bash

# buildfly 项目管理脚本
# 提供编译、运行、测试、格式化、lint等常用开发命令

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 项目信息
PROJECT_NAME="buildfly"
VERSION=$(cat go.mod | grep -E "^module" | awk '{print $2}' | cut -d'/' -f2-)

# 打印带颜色的消息
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 显示帮助信息
show_help() {
    cat << EOF
buildfly 项目管理脚本

用法: $0 <命令> [选项]

可用命令:
    build           编译项目
    run             运行项目
    test            运行测试
    fmt             格式化代码
    lint            代码检查
    clean           清理构建文件
    install         安装依赖
    dev             air开发模式（监听文件变化）
    docker          Docker 相关操作
    release         发布版本
    help            显示此帮助信息

构建选项:
    -v, --verbose   详细输出
    -r, --release   发布模式编译
    -d, --debug     调试模式编译

测试选项:
    -c, --cover     显示测试覆盖率
    -v, --verbose   详细测试输出
    -r, --race      竞态检测

Docker 选项:
    build           构建 Docker 镜像
    run             运行 Docker 容器
    push            推送镜像到仓库

示例:
    $0 build                    # 编译项目
    $0 test -c                  # 运行测试并显示覆盖率
    $0 fmt                      # 格式化代码
    $0 docker build             # 构建 Docker 镜像
    $0 release v1.0.0           # 发布 v1.0.0 版本

EOF
}

# 检查命令是否存在
check_command() {
    if ! command -v $1 &> /dev/null; then
        print_error "$1 命令未找到，请先安装"
        exit 1
    fi
}

# 编译项目
build_project() {
    local build_mode="build"
    local ldflags=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -r|--release)
                build_mode="build -ldflags \"-s -w\""
                ldflags="-ldflags \"-s -w\""
                shift
                ;;
            -d|--debug)
                build_mode="build -gcflags=\"all=-N -l\""
                shift
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    print_info "开始编译 ${PROJECT_NAME}..."
    
    # 创建 bin 目录
    mkdir -p bin
    
    # 获取构建信息
    local git_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    local build_date=$(date -u '+%Y-%m-%d_%H:%M:%S_UTC' 2>/dev/null || echo "unknown")
    local go_version=$(go version | awk '{print $3}' | sed 's/go//' 2>/dev/null || echo "unknown")
    
    print_info "构建信息："
    print_info "  Git Commit: ${git_commit}"
    print_info "  Build Date: ${build_date//_/ }"
    print_info "  Go Version: ${go_version}"
    
    # 编译主程序
    if [ -n "$ldflags" ]; then
        # 发布模式
        go build -ldflags "-X buildfly/internal/constants.GitCommit=${git_commit} -X buildfly/internal/constants.BuildDate=${build_date} -X buildfly/internal/constants.GoVersion=${go_version} -s -w" -o bin/${PROJECT_NAME} ./cmd/main.go
    else
        # 普通模式
        go build -ldflags "-X buildfly/internal/constants.GitCommit=${git_commit} -X buildfly/internal/constants.BuildDate=${build_date} -X buildfly/internal/constants.GoVersion=${go_version}" -o bin/${PROJECT_NAME} ./cmd/main.go
    fi
    
    print_success "编译完成: bin/${PROJECT_NAME}"
}

# 运行项目
run_project() {
    print_info "运行 ${PROJECT_NAME}..."
    
    if [ ! -f "bin/${PROJECT_NAME}" ]; then
        print_warning "未找到编译后的文件，先进行编译..."
        build_project
    fi
    
    ./bin/${PROJECT_NAME} "$@"
}

# 运行测试
run_tests() {
    local cover=false
    local race=false
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -c|--cover)
                cover=true
                shift
                ;;
            -r|--race)
                race=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    print_info "运行测试..."
    
    local test_args=""
    
    if [ "$cover" = true ]; then
        test_args="$test_args -coverprofile=coverage.out -covermode=atomic"
    fi
    
    if [ "$race" = true ]; then
        test_args="$test_args -race"
    fi
    
    if [ "$verbose" = true ]; then
        test_args="$test_args -v"
    fi
    
    # 运行单元测试
    go test $test_args ./...
    
    # 生成覆盖率报告
    if [ "$cover" = true ]; then
        if command -v go tool cover &> /dev/null; then
            go tool cover -html=coverage.out -o coverage.html
            print_success "覆盖率报告已生成: coverage.html"
        fi
    fi
    
    print_success "测试完成"
}

# 格式化代码
format_code() {
    print_info "格式化代码..."
    
    # 格式化 Go 代码
    if command -v goimports &> /dev/null; then
        goimports -w .
    else
        go fmt ./...
    fi
    
    # 格式化 Shell 脚本
    if command -v shfmt &> /dev/null; then
        shfmt -w -i 4 .
    fi
    
    print_success "代码格式化完成"
}

# 代码检查
lint_code() {
    print_info "进行代码检查..."
    
    # 检查 Go 代码
    if command -v golangci-lint &> /dev/null; then
        golangci-lint run
    elif command -v golint &> /dev/null; then
        golint ./...
    else
        print_warning "未安装 golangci-lint 或 golint，跳过 Go 代码检查"
    fi
    
    # 检查 Shell 脚本
    if command -v shellcheck &> /dev/null; then
        shellcheck *.sh
    fi
    
    # 检查 YAML 文件
    if command -v yamllint &> /dev/null; then
        yamllint *.yaml
    fi
    
    print_success "代码检查完成"
}

# 清理构建文件
clean_build() {
    print_info "清理构建文件..."
    
    # 清理编译产物
    rm -rf bin/
    rm -f coverage.out coverage.html
    
    # 清理 Go 模块缓存
    go clean -modcache
    
    # 清理测试缓存
    go clean -testcache
    
    print_success "清理完成"
}

# 安装依赖
install_deps() {
    print_info "安装依赖..."
    
    # 下载 Go 模块依赖
    go mod download
    go mod tidy
    
    # 安装开发工具
    check_command go
    
    # 安装常用的 Go 工具
    local tools=(
        "golang.org/x/tools/cmd/goimports"
        "github.com/golangci/golangci-lint/cmd/golangci-lint"
        "honnef.co/go/tools/cmd/staticcheck"
    )
    
    for tool in "${tools[@]}"; do
        if ! command -v $(basename $tool) &> /dev/null; then
            print_info "安装 $tool..."
            go install $tool@latest
        fi
    done
    
    print_success "依赖安装完成"
}

# 开发模式 watch 自动编译模式
dev_mode() {
    print_info "启动air开发模式..."

    # 检查是否已有air进程在运行
    if [ -f "logs/air.pid" ]; then
        local air_pid=$(cat logs/air.pid)
        if kill -0 $air_pid 2>/dev/null; then
            print_info "发现正在运行的air进程(PID: $air_pid)，正在停止..."
            kill $air_pid
            sleep 2
        else
            print_info "PID文件存在但进程已不存在，清理旧的PID文件..."
        fi
        rm -f logs/air.pid
    fi

    # 确保logs目录存在
    mkdir -p logs

    # 启动air并保存PID
    nohup air > logs/air.log 2>&1 &
    local new_pid=$!

    echo $new_pid > logs/air.pid
    print_info "Air已启动，PID: $new_pid"
    print_info "日志文件: logs/air.log"
    print_info "PID文件: logs/air.pid"
}

# Docker 相关操作
docker_ops() {
    local action=$1
    shift
    
    case $action in
        build)
            print_info "构建 Docker 镜像..."
            docker build -t ${PROJECT_NAME}:latest .
            print_success "Docker 镜像构建完成"
            ;;
        run)
            print_info "运行 Docker 容器..."
            docker run -it --rm ${PROJECT_NAME}:latest "$@"
            ;;
        push)
            local tag=${1:-latest}
            print_info "推送 Docker 镜像..."
            docker tag ${PROJECT_NAME}:latest ${PROJECT_NAME}:${tag}
            docker push ${PROJECT_NAME}:${tag}
            print_success "Docker 镜像推送完成"
            ;;
        *)
            print_error "未知的 Docker 操作: $action"
            exit 1
            ;;
    esac
}

# 发布版本
release_version() {
    local version=$1
    
    if [ -z "$version" ]; then
        print_error "请指定版本号，例如: $0 release v1.0.0"
        exit 1
    fi
    
    print_info "发布版本 $version..."
    
    # 检查是否有未提交的更改
    if [ -n "$(git status --porcelain)" ]; then
        print_error "存在未提交的更改，请先提交代码"
        exit 1
    fi
    
    # 创建 Git 标签
    git tag -a $version -m "Release $version"
    git push origin $version
    
    # 构建发布版本
    build_project --release
    
    # 创建发布包
    local release_dir="releases/${version}"
    mkdir -p $release_dir
    
    # 复制二进制文件
    cp bin/${PROJECT_NAME} $release_dir/
    
    # 创建压缩包
    cd releases
    tar -czf ${PROJECT_NAME}-${version}-$(go env GOOS)-$(go env GOARCH).tar.gz $version/
    cd ..
    
    print_success "版本 $version 发布完成"
}

# 主函数
main() {
    local command=$1
    if [[ -z "$command" ]];then
        show_help
        exit 0
    fi
    shift
    case $command in
        build)
            build_project "$@"
            ;;
        run)
            run_project "$@"
            ;;
        test)
            run_tests "$@"
            ;;
        fmt|format)
            format_code
            ;;
        lint)
            lint_code
            ;;
        clean)
            clean_build
            ;;
        install)
            install_deps
            ;;
        dev)
            dev_mode
            ;;
        docker)
            docker_ops "$@"
            ;;
        release)
            release_version "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            print_error "未知命令: $command"
            echo
            show_help
            exit 1
            ;;
    esac
}

# 检查是否在项目根目录
if [ ! -f "go.mod" ]; then
    print_error "请在项目根目录运行此脚本"
    exit 1
fi

# 执行主函数
main "$@"
