package venv

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

// UVBackend UV 后端实现
type UVBackend struct {
	info     *UVInfo
	rootDir  string
	config   *VEnvConfig
	detector *UVDetector
}

// NewUVBackend 创建 UV 后端实例
func NewUVBackend() *UVBackend {
	return &UVBackend{
		detector: NewUVDetector(),
	}
}

// Detect 检测 UV 是否已安装
func (u *UVBackend) Detect() (*BackendInfo, error) {
	info, err := u.detector.DetectUV()
	if err != nil {
		return &BackendInfo{
			Name:      "uv",
			Installed: false,
		}, nil
	}

	u.info = info

	return &BackendInfo{
		Name:      "uv",
		Version:   info.Version,
		Path:      info.Path,
		Installed: info.Installed,
		Environment: map[string]string{
			"UV_INDEX_URL":       os.Getenv("UV_INDEX_URL"),
			"UV_EXTRA_INDEX_URL": os.Getenv("UV_EXTRA_INDEX_URL"),
		},
	}, nil
}

// Install 安装 UV
func (u *UVBackend) Install(version string) error {
	return u.detector.InstallUV(version)
}

// Initialize 初始化 UV 环境
func (u *UVBackend) Initialize(config *VEnvConfig, rootDir string) error {
	u.config = config
	u.rootDir = rootDir

	fmt.Printf("Initializing UV environment at: %s\n", rootDir)

	// 检测并安装 UV
	if err := u.ensureUVInstalled(); err != nil {
		return fmt.Errorf("failed to ensure UV is installed: %w", err)
	}

	// 创建 UV 配置文件
	if err := u.CreateConfig(config, rootDir); err != nil {
		return fmt.Errorf("failed to create UV config: %w", err)
	}

	// 使用UV创建Python虚拟环境
	if err := u.createPythonEnvironment(); err != nil {
		return fmt.Errorf("failed to create Python environment: %w", err)
	}

	// 安装C++构建工具
	if err := u.installCPPTools(); err != nil {
		return fmt.Errorf("failed to install C++ tools: %w", err)
	}

	// 创建环境激活脚本
	if err := u.createActivationScripts(); err != nil {
		return fmt.Errorf("failed to create activation scripts: %w", err)
	}

	fmt.Println("UV environment initialized successfully")
	return nil
}

// CreateConfig 创建 UV 配置文件
func (u *UVBackend) CreateConfig(config *VEnvConfig, rootDir string) error {
	// 获取 .buildfly 目录路径
	buildflyDir := filepath.Dir(rootDir)
	uvConfigPath := filepath.Join(buildflyDir, "uv.toml")

	// 检查文件是否已存在
	if _, err := os.Stat(uvConfigPath); err == nil {
		fmt.Printf("UV config file already exists: %s\n", uvConfigPath)
		return nil
	}

	// 创建默认的 UV 配置内容
	uvConfigContent := fmt.Sprintf(`# BuildFly UV Configuration
# Generated by buildfly venv init

[pypi]
index = "%s"

[tool.uv]
dev-dependencies = [
%s]
`, u.getDefaultIndexURL(), u.getDefaultDependencies())

	// 确保 .buildfly 目录存在
	if err := os.MkdirAll(buildflyDir, 0755); err != nil {
		return fmt.Errorf("failed to create .buildfly directory: %w", err)
	}

	// 写入配置文件
	if err := os.WriteFile(uvConfigPath, []byte(uvConfigContent), 0644); err != nil {
		return fmt.Errorf("failed to write UV config file: %w", err)
	}

	fmt.Printf("Created UV config file: %s\n", uvConfigPath)
	return nil
}

// ensureUVInstalled 确保 UV 已安装
func (u *UVBackend) ensureUVInstalled() error {
	if u.info == nil {
		info, err := u.detector.DetectUV()
		if err != nil {
			return fmt.Errorf("failed to detect UV: %w", err)
		}
		u.info = info
	}

	if !u.info.Installed {
		fmt.Println("UV not found, installing...")
		if err := u.detector.InstallUV(u.config.UVVersion); err != nil {
			return fmt.Errorf("failed to install UV: %w", err)
		}
		fmt.Println("UV installed successfully")
	} else {
		fmt.Printf("UV already installed: %s (version: %s)\n", u.info.Path, u.info.Version)
	}

	return nil
}

// createPythonEnvironment 使用UV创建Python虚拟环境
func (u *UVBackend) createPythonEnvironment() error {
	fmt.Println("Creating Python virtual environment with UV...")

	if u.info == nil || !u.info.Installed {
		return fmt.Errorf("UV is not installed")
	}

	// 设置环境变量
	env := os.Environ()

	// 添加 UV_ENV_FILE 环境变量
	uvConfigPath := u.getUVConfigPath()
	if _, err := os.Stat(uvConfigPath); err == nil {
		env = append(env, fmt.Sprintf("UV_ENV_FILE=%s", uvConfigPath))
	}

	// 检查是否已经有虚拟环境
	if _, err := os.Stat(filepath.Join(u.rootDir, "pyvenv.cfg")); err == nil {
		fmt.Printf("Python virtual environment already exists at: %s\n", u.rootDir)
	} else {
		// 使用UV直接在rootDir下创建虚拟环境
		cmd := exec.Command(u.info.Path, "venv", u.rootDir, "--python", u.config.Python.Version)
		cmd.Dir = filepath.Dir(u.rootDir)
		cmd.Env = env
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to create Python virtual environment: %w", err)
		}

		fmt.Printf("Python %s virtual environment created at: %s\n", u.config.Python.Version, u.rootDir)
	}

	// 安装Python包
	if len(u.config.Python.Packages) > 0 {
		fmt.Printf("Installing Python packages: %v\n", u.config.Python.Packages)
		for _, pkg := range u.config.Python.Packages {
			if err := u.installPythonPackage(pkg); err != nil {
				fmt.Printf("Warning: failed to install package %s: %v\n", pkg, err)
			}
		}
	}

	return nil
}

// installPythonPackage 安装Python包
func (u *UVBackend) installPythonPackage(packageName string) error {
	if u.info == nil || !u.info.Installed {
		return fmt.Errorf("UV is not installed")
	}

	cmd := exec.Command(u.info.Path, "pip", "install", packageName, "--python", u.rootDir)
	cmd.Dir = u.rootDir

	// 设置环境变量
	env := os.Environ()

	// 添加 UV_ENV_FILE 环境变量
	uvConfigPath := u.getUVConfigPath()
	if _, err := os.Stat(uvConfigPath); err == nil {
		env = append(env, fmt.Sprintf("UV_ENV_FILE=%s", uvConfigPath))
	}

	cmd.Env = env
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

// installCPPTools 安装C++构建工具
func (u *UVBackend) installCPPTools() error {
	fmt.Println("Installing C++ build tools...")

	if u.info == nil || !u.info.Installed {
		return fmt.Errorf("UV is not installed")
	}

	// 安装CMake
	if u.config.CPPTools.CMake.Enabled {
		if err := u.installCMake(); err != nil {
			return fmt.Errorf("failed to install CMake: %w", err)
		}
	}

	// 安装Ninja
	if u.config.CPPTools.Ninja.Enabled {
		if err := u.installNinja(); err != nil {
			return fmt.Errorf("failed to install Ninja: %w", err)
		}
	}

	return nil
}

// installCMake 安装CMake
func (u *UVBackend) installCMake() error {
	fmt.Printf("Installing CMake %s...\n", u.config.CPPTools.CMake.Version)

	// 设置环境变量
	env := os.Environ()

	// 添加 UV_ENV_FILE 环境变量
	uvConfigPath := u.getUVConfigPath()
	if _, err := os.Stat(uvConfigPath); err == nil {
		env = append(env, fmt.Sprintf("UV_ENV_FILE=%s", uvConfigPath))
	}

	// 使用UV安装CMake
	cmd := exec.Command(u.info.Path, "tool", "install", "cmake=="+u.config.CPPTools.CMake.Version)
	cmd.Dir = u.rootDir
	cmd.Env = env
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to install CMake: %w", err)
	}

	fmt.Println("CMake installed successfully")
	return nil
}

// installNinja 安装Ninja
func (u *UVBackend) installNinja() error {
	fmt.Printf("Installing Ninja %s...\n", u.config.CPPTools.Ninja.Version)

	// 设置环境变量
	env := os.Environ()

	// 添加 UV_ENV_FILE 环境变量
	uvConfigPath := u.getUVConfigPath()
	if _, err := os.Stat(uvConfigPath); err == nil {
		env = append(env, fmt.Sprintf("UV_ENV_FILE=%s", uvConfigPath))
	}

	// 使用UV安装Ninja
	cmd := exec.Command(u.info.Path, "tool", "install", "ninja=="+u.config.CPPTools.Ninja.Version)
	cmd.Dir = u.rootDir
	cmd.Env = env
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to install Ninja: %w", err)
	}

	fmt.Println("Ninja installed successfully")
	return nil
}

// createActivationScripts 创建环境激活脚本
func (u *UVBackend) createActivationScripts() error {
	// Unix/Linux/macOS 激活脚本
	unixScript := fmt.Sprintf(`#!/bin/bash
# BuildFly UV Environment Activation Script

export BUILDFLY_ENV_ROOT="%s"
export BUILDFLY_BACKEND="uv"
export PATH="%s/bin:$PATH"

# 设置编译器环境变量
if [ -f "%s/bin/gcc" ]; then
    export CC="%s/bin/gcc"
    export CXX="%s/bin/g++"
fi

if [ -f "%s/bin/clang" ]; then
    export CC="%s/bin/clang"
    export CXX="%s/bin/clang++"
fi

# 设置 CMake 环境变量
if [ -d "%s/tools/cmake" ]; then
    export CMAKE_PREFIX_PATH="%s/tools/cmake:$CMAKE_PREFIX_PATH"
    export PATH="%s/tools/cmake/bin:$PATH"
fi

echo "BuildFly UV environment activated"
echo "Environment root: $BUILDFLY_ENV_ROOT"
`, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir)

	unixScriptFile := filepath.Join(u.rootDir, "activate.sh")
	if err := os.WriteFile(unixScriptFile, []byte(unixScript), 0755); err != nil {
		return fmt.Errorf("failed to write Unix activation script: %w", err)
	}

	// Windows 激活脚本
	windowsScript := fmt.Sprintf(`@echo off
REM BuildFly UV Environment Activation Script

set BUILDFLY_ENV_ROOT=%s
set BUILDFLY_BACKEND=uv
set PATH=%s\bin;%%PATH%%

REM 设置编译器环境变量
if exist "%s\bin\gcc.exe" (
    set CC=%s\bin\gcc.exe
    set CXX=%s\bin\g++.exe
)

if exist "%s\bin\clang.exe" (
    set CC=%s\bin\clang.exe
    set CXX=%s\bin\clang++.exe
)

REM 设置 CMake 环境变量
if exist "%s\tools\cmake" (
    set CMAKE_PREFIX_PATH=%s\tools\cmake;%%CMAKE_PREFIX_PATH%%
    set PATH=%s\tools\cmake\bin;%%PATH%%
)

echo BuildFly UV environment activated
echo Environment root: %%BUILDFLY_ENV_ROOT%%
`, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir, u.rootDir)

	windowsScriptFile := filepath.Join(u.rootDir, "activate.bat")
	if err := os.WriteFile(windowsScriptFile, []byte(windowsScript), 0755); err != nil {
		return fmt.Errorf("failed to write Windows activation script: %w", err)
	}

	return nil
}

// Activate 激活环境
func (u *UVBackend) Activate() error {
	// 设置环境变量
	os.Setenv("BUILDFLY_ENV_ROOT", u.rootDir)
	os.Setenv("BUILDFLY_BACKEND", "uv")

	// 添加 bin 目录到 PATH
	binDir := filepath.Join(u.rootDir, "bin")
	currentPath := os.Getenv("PATH")
	newPath := binDir + string(filepath.ListSeparator) + currentPath
	os.Setenv("PATH", newPath)

	fmt.Printf("UV environment activated: %s\n", u.rootDir)
	return nil
}

// Deactivate 停用环境
func (u *UVBackend) Deactivate() error {
	os.Unsetenv("BUILDFLY_ENV_ROOT")
	os.Unsetenv("BUILDFLY_BACKEND")

	fmt.Println("UV environment deactivated")
	return nil
}

// Run 在环境中运行命令
func (u *UVBackend) Run(args []string) error {
	if u.info == nil || !u.info.Installed {
		return fmt.Errorf("UV is not installed")
	}

	if len(args) == 0 {
		return fmt.Errorf("no command specified")
	}

	// 构建UV命令参数
	var uvArgs []string
	uvArgs = append(uvArgs, "tool", "run")
	uvArgs = append(uvArgs, args...)

	// 设置环境变量
	env := os.Environ()

	// 添加虚拟环境相关的环境变量
	env = append(env, fmt.Sprintf("BUILDFLY_ENV_ROOT=%s", u.rootDir))
	env = append(env, "BUILDFLY_BACKEND=uv")

	// 添加bin目录到PATH
	binDir := filepath.Join(u.rootDir, "bin")
	currentPath := os.Getenv("PATH")
	newPath := binDir + string(filepath.ListSeparator) + currentPath
	env = append(env, fmt.Sprintf("PATH=%s", newPath))

	// 添加UV配置环境变量
	if u.config.UV.IndexURL != "" {
		env = append(env, fmt.Sprintf("UV_INDEX_URL=%s", u.config.UV.IndexURL))
	}

	for _, extraIndex := range u.config.UV.ExtraIndexURL {
		env = append(env, fmt.Sprintf("UV_EXTRA_INDEX_URL=%s", extraIndex))
	}

	// 添加 UV_ENV_FILE 环境变量
	uvConfigPath := u.getUVConfigPath()
	if _, err := os.Stat(uvConfigPath); err == nil {
		env = append(env, fmt.Sprintf("UV_ENV_FILE=%s", uvConfigPath))
	}

	// 添加自定义环境变量
	for key, value := range u.config.UV.Environment {
		env = append(env, fmt.Sprintf("%s=%s", key, value))
	}

	// 执行命令 - 根据平台选择不同的激活方式
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		// Windows: 使用 cmd /c 调用 activate.bat
		cmd = exec.Command("cmd", "/c", fmt.Sprintf("%s && %s", u.getActivationScript(), joinArgsUV(args)))
	default:
		// Unix/Linux/macOS: 使用 bash -c 调用 source activate.sh
		cmd = exec.Command("bash", "-c", fmt.Sprintf("source %s && %s", u.getActivationScript(), joinArgsUV(args)))
	}

	cmd.Env = env
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

// GetInfo 获取后端信息
func (u *UVBackend) GetInfo() *BackendInfo {
	if u.info == nil {
		info, _ := u.detector.DetectUV()
		u.info = info
	}

	return &BackendInfo{
		Name:      "uv",
		Version:   u.info.Version,
		Path:      u.info.Path,
		Installed: u.info.Installed,
		Environment: map[string]string{
			"UV_INDEX_URL":       os.Getenv("UV_INDEX_URL"),
			"UV_EXTRA_INDEX_URL": os.Getenv("UV_EXTRA_INDEX_URL"),
		},
	}
}

// InstallTool 安装指定工具
func (u *UVBackend) InstallTool(toolName, version string) error {
	if u.info == nil || !u.info.Installed {
		return fmt.Errorf("UV is not installed")
	}

	pkgSpec := toolName
	if version != "" {
		pkgSpec = fmt.Sprintf("%s==%s", toolName, version)
	}

	cmd := exec.Command(u.info.Path, "tool", "install", pkgSpec)
	cmd.Dir = u.rootDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to install tool %s: %w", toolName, err)
	}

	return nil
}

// 辅助函数

// getDefaultIndexURL 获取默认的 PyPI 索引 URL
func (u *UVBackend) getDefaultIndexURL() string {
	if u.config.UV.IndexURL != "" {
		return u.config.UV.IndexURL
	}
	return "https://pypi.org/simple/"
}

// getDefaultDependencies 获取默认依赖列表
func (u *UVBackend) getDefaultDependencies() string {
	var deps []string

	// 添加 Python 包依赖
	for _, pkg := range u.config.Python.Packages {
		deps = append(deps, fmt.Sprintf("    %q,", pkg))
	}

	// 添加 C++ 工具依赖
	if u.config.CPPTools.CMake.Enabled {
		deps = append(deps, fmt.Sprintf("    %q,", "cmake=="+u.config.CPPTools.CMake.Version))
	}
	if u.config.CPPTools.Ninja.Enabled {
		deps = append(deps, fmt.Sprintf("    %q,", "ninja=="+u.config.CPPTools.Ninja.Version))
	}

	if len(deps) == 0 {
		return ""
	}

	return strings.Join(deps, "\n")
}

// getUVConfigPath 获取 UV 配置文件路径
func (u *UVBackend) getUVConfigPath() string {
	buildflyDir := filepath.Dir(u.rootDir)
	return filepath.Join(buildflyDir, "uv.toml")
}

// getActivationScript 获取激活脚本路径
func (u *UVBackend) getActivationScript() string {
	switch runtime.GOOS {
	case "windows":
		return filepath.Join(u.rootDir, "activate.bat")
	default:
		return filepath.Join(u.rootDir, "activate.sh")
	}
}

// joinArgsUV 将字符串数组连接成适合在 bash 中执行的命令字符串
func joinArgsUV(args []string) string {
	if len(args) == 0 {
		return ""
	}

	var escapedArgs []string
	for _, arg := range args {
		// 对包含空格、引号等特殊字符的参数进行转义
		if strings.ContainsAny(arg, " \t\n\r\"'`$&*()[]{}|;<>?") {
			escapedArgs = append(escapedArgs, fmt.Sprintf("'%s'", strings.ReplaceAll(arg, "'", "'\"'\"'")))
		} else {
			escapedArgs = append(escapedArgs, arg)
		}
	}

	return strings.Join(escapedArgs, " ")
}
