#!/bin/bash

# Go Wrapper (gow) - 自动管理 Go 版本和依赖
# 基于 Go 官方文档实现的多版本管理

set -e

GOW_VERSION="2.0.0"
GO_VERSION_FILE=".go-version"
GOW_GLOBAL_VERSION_FILE="$HOME/.gow/global-version"
GOW_DIR=".gow"
GOW_HOME="$HOME/.gow"
GOW_VERSIONS_DIR="$GOW_HOME/versions"
GOW_CACHE_DIR="$GOW_HOME/cache"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

info() { echo -e "${BLUE}[INFO]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
debug() { echo -e "${CYAN}[DEBUG]${NC} $1"; }

# 显示帮助
show_help() {
    cat << EOF
Go Wrapper (gow) v$GOW_VERSION

用法:
  gow <command> [arguments]

核心命令:
  run         运行 Go 程序
  build       编译项目
  test        运行测试
  mod         Go modules 相关操作
  
版本管理:
  use <version>    切换到指定 Go 版本
  install <version> 安装指定 Go 版本
  uninstall <version> 卸载指定 Go 版本
  list             列出已安装的版本
  list-remote      列出可用的远程版本
  current          显示当前使用的版本
  
项目管理:
  init             初始化 gow 项目配置
  deps             管理依赖
  clean            清理构建文件和缓存
  
工具命令:
  version          显示 gow 和 Go 版本信息
  doctor           检查环境和配置
  update           更新 gow 自身
  self-update      更新 gow 到最新版本

示例:
  gow run main.go
  gow use 1.21.0
  gow install 1.20.5
  gow test ./...
  gow mod tidy
  gow deps update
  gow doctor

配置文件:
  .go-version      项目级 Go 版本配置
  ~/.gow/global-version  全局默认 Go 版本
EOF
}

# 检测操作系统和架构
detect_platform() {
    OS=$(uname | tr '[:upper:]' '[:lower:]')
    ARCH=$(uname -m)
    
    case $ARCH in
        x86_64) ARCH="amd64" ;;
        i386|i686) ARCH="386" ;;
        armv6l) ARCH="armv6l" ;;
        armv7l) ARCH="armv6l" ;;
        aarch64) ARCH="arm64" ;;
        arm64) ARCH="arm64" ;;
    esac
    
    # 处理特殊的操作系统
    case $OS in
        darwin) OS="darwin" ;;
        linux) OS="linux" ;;
        freebsd) OS="freebsd" ;;
        windows) OS="windows" ;;
    esac
    
    echo "${OS}-${ARCH}"
}

# 检查系统是否有 Go
check_system_go() {
    if command -v go >/dev/null 2>&1; then
        local go_path=$(command -v go)
        if [ -x "$go_path" ]; then
            "$go_path" version 2>/dev/null
            return 0
        fi
    fi
    return 1
}

# 获取 Go 版本号（标准化格式）
normalize_go_version() {
    local version="$1"
    # 移除 'go' 前缀
    version=$(echo "$version" | sed 's/^go//')
    # 确保版本号格式正确 (如 1.21.0)
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
        error "无效的 Go 版本格式: $version"
        return 1
    fi
    echo "$version"
}

# 获取已安装的 Go 版本列表
list_installed_versions() {
    if [ -d "$GOW_VERSIONS_DIR" ]; then
        find "$GOW_VERSIONS_DIR" -maxdepth 1 -type d -name "go*" | \
        sed 's|.*/||' | sort -V
    fi
}

# 检查指定版本是否已安装
is_version_installed() {
    local version="$1"
    [ -d "$GOW_VERSIONS_DIR/go$version" ] && [ -x "$GOW_VERSIONS_DIR/go$version/bin/go" ]
}

# 获取 Go 下载 URL
get_go_download_url() {
    local version="$1"
    local platform=$(detect_platform)
    local filename="go${version}.${platform}.tar.gz"
    
    # 对于 Windows，使用 .zip 格式
    if [[ "$platform" == windows-* ]]; then
        filename="go${version}.${platform}.zip"
    fi
    
    echo "https://go.dev/dl/${filename}"
}

# 安装指定版本的 Go
install_go_version() {
    local version="$1"
    version=$(normalize_go_version "$version")
    
    if is_version_installed "$version"; then
        info "Go $version 已经安装"
        return 0
    fi
    
    info "正在安装 Go $version..."
    
    # 创建必要目录
    mkdir -p "$GOW_VERSIONS_DIR" "$GOW_CACHE_DIR"
    
    local platform=$(detect_platform)
    local download_url=$(get_go_download_url "$version")
    local filename="go${version}.${platform}"
    
    # 根据平台设置文件扩展名
    if [[ "$platform" == windows-* ]]; then
        filename="${filename}.zip"
    else
        filename="${filename}.tar.gz"
    fi
    
    local cache_file="$GOW_CACHE_DIR/$filename"
    
    # 下载 Go (如果缓存中没有)
    if [ ! -f "$cache_file" ]; then
        info "正在下载 Go $version 从 $download_url..."
        if command -v curl >/dev/null 2>&1; then
            curl -L -o "$cache_file" "$download_url"
        elif command -v wget >/dev/null 2>&1; then
            wget -O "$cache_file" "$download_url"
        else
            error "需要 curl 或 wget 来下载 Go"
            return 1
        fi
    else
        info "使用缓存的文件: $cache_file"
    fi
    
    # 解压安装
    local install_dir="$GOW_VERSIONS_DIR/go$version"
    mkdir -p "$install_dir"
    
    info "正在解压到 $install_dir..."
    if [[ "$platform" == windows-* ]]; then
        if command -v unzip >/dev/null 2>&1; then
            unzip -q "$cache_file" -d "$GOW_CACHE_DIR"
            mv "$GOW_CACHE_DIR/go"/* "$install_dir/"
            rmdir "$GOW_CACHE_DIR/go"
        else
            error "需要 unzip 来解压 Windows 版本的 Go"
            return 1
        fi
    else
        tar -C "$install_dir" --strip-components=1 -xzf "$cache_file"
    fi
    
    # 验证安装
    local go_binary="$install_dir/bin/go"
    if [ -x "$go_binary" ]; then
        local installed_version=$("$go_binary" version | cut -d' ' -f3 | sed 's/go//')
        if [ "$installed_version" = "$version" ]; then
            success "Go $version 安装成功!"
            info "安装路径: $install_dir"
            return 0
        else
            warn "版本不匹配: 期望 $version, 实际 $installed_version"
            warn "这可能是由于下载的文件有问题"
            info "安装路径: $install_dir"
            return 1
        fi
    else
        error "Go 安装失败"
        return 1
    fi
}

# 卸载指定版本的 Go
uninstall_go_version() {
    local version="$1"
    version=$(normalize_go_version "$version")
    
    if ! is_version_installed "$version"; then
        warn "Go $version 未安装"
        return 1
    fi
    
    info "正在卸载 Go $version..."
    rm -rf "$GOW_VERSIONS_DIR/go$version"
    success "Go $version 已卸载"
}

# 切换 Go 版本
use_go_version() {
    local version="$1"
    version=$(normalize_go_version "$version")
    
    if ! is_version_installed "$version"; then
        warn "Go $version 未安装"
        info "使用 'gow install $version' 来安装"
        return 1
    fi
    
    # 设置项目级版本
    echo "$version" > "$GO_VERSION_FILE"
    success "项目 Go 版本已设置为 $version"
    info "运行 'gow doctor' 来验证配置"
}

# 获取当前应该使用的 Go 版本
get_current_go_version() {
    # 优先级：项目版本 > 全局版本 > 系统版本
    if [ -f "$GO_VERSION_FILE" ]; then
        cat "$GO_VERSION_FILE"
    elif [ -f "$GOW_GLOBAL_VERSION_FILE" ]; then
        cat "$GOW_GLOBAL_VERSION_FILE"
    else
        # 返回系统版本（如果有）
        if check_system_go >/dev/null 2>&1; then
            go version 2>/dev/null | cut -d' ' -f3 | sed 's/go//'
        fi
    fi
}

# 获取当前 Go 二进制路径
get_go_binary() {
    local version=$(get_current_go_version)
    if [ -n "$version" ]; then
        version=$(normalize_go_version "$version")
        if is_version_installed "$version"; then
            echo "$GOW_VERSIONS_DIR/go$version/bin/go"
            return 0
        fi
    fi
    
    # 回退到系统 Go
    if command -v go >/dev/null 2>&1; then
        command -v go
        return 0
    fi
    
    return 1
}

# 初始化 gow 配置
init_gow() {
    info "初始化 gow 项目配置..."
    
    # 创建全局目录
    mkdir -p "$GOW_HOME" "$GOW_VERSIONS_DIR" "$GOW_CACHE_DIR"
    
    # 创建项目级目录
    if [ ! -d "$GOW_DIR" ]; then
        mkdir -p "$GOW_DIR"
        info "创建 $GOW_DIR 目录"
    fi
    
    # 检测当前 Go 版本并设置
    local current_go=""
    if check_system_go >/dev/null 2>&1; then
        current_go=$(go version | cut -d' ' -f3 | sed 's/go//')
    fi
    
    if [ ! -f "$GO_VERSION_FILE" ]; then
        if [ -n "$current_go" ]; then
            echo "$current_go" > "$GO_VERSION_FILE"
            info "创建 $GO_VERSION_FILE，当前 Go 版本: $current_go"
        else
            warn "未检测到系统 Go，请手动设置版本: gow use <version>"
        fi
    fi
    
    # 创建项目 gitignore
    if [ ! -f "$GOW_DIR/.gitignore" ]; then
        cat > "$GOW_DIR/.gitignore" << EOF
# gow 忽略文件
.cache/
build/
dist/
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
go.work.sum
EOF
    fi
    
    # 创建全局 gitignore
    if [ ! -f "$GOW_HOME/.gitignore" ]; then
        cat > "$GOW_HOME/.gitignore" << EOF
# gow 全局忽略文件
cache/
versions/
*.log
EOF
    fi
    
    success "gow 初始化完成"
    info "运行 'gow doctor' 检查环境配置"
}

# 环境检查
doctor() {
    info "正在检查 gow 环境..."
    
    echo
    echo "=== 系统信息 ==="
    echo "平台: $(detect_platform)"
    echo "Shell: $SHELL"
    
    echo
    echo "=== Go 版本信息 ==="
    
    # 检查系统 Go
    if check_system_go >/dev/null 2>&1; then
        local system_go=$(go version 2>/dev/null)
        echo "系统 Go: $system_go"
    else
        echo "系统 Go: 未安装"
    fi
    
    # 检查当前项目版本
    local current_version=$(get_current_go_version)
    if [ -n "$current_version" ]; then
        echo "项目配置版本: go$current_version"
    else
        echo "项目配置版本: 未设置"
    fi
    
    echo
    echo "=== gow 管理的版本 ==="
    local installed_versions=$(list_installed_versions)
    if [ -n "$installed_versions" ]; then
        echo "已安装的版本:"
        echo "$installed_versions" | while read -r version; do
            if [ "$version" = "go$current_version" ]; then
                echo "  ✓ $version (当前)"
            else
                echo "    $version"
            fi
        done
    else
        echo "已安装的版本: 无"
    fi
    
    echo
    echo "=== 配置文件 ==="
    if [ -f "$GO_VERSION_FILE" ]; then
        echo "项目版本文件: $GO_VERSION_FILE ($(cat "$GO_VERSION_FILE"))"
    else
        echo "项目版本文件: 不存在"
    fi
    
    if [ -f "$GOW_GLOBAL_VERSION_FILE" ]; then
        echo "全局版本文件: $GOW_GLOBAL_VERSION_FILE ($(cat "$GOW_GLOBAL_VERSION_FILE"))"
    else
        echo "全局版本文件: 不存在"
    fi
    
    echo
    echo "=== 目录结构 ==="
    echo "gow 主目录: $GOW_HOME"
    echo "版本目录: $GOW_VERSIONS_DIR"
    echo "缓存目录: $GOW_CACHE_DIR"
    
    echo
    echo "=== 路径检查 ==="
    local go_binary=$(get_go_binary)
    if [ -n "$go_binary" ]; then
        echo "当前 Go 二进制: $go_binary"
        if [ -x "$go_binary" ]; then
            local actual_version=$("$go_binary" version 2>/dev/null)
            echo "版本验证: $actual_version"
            success "环境配置正常"
        else
            error "Go 二进制不可执行: $go_binary"
        fi
    else
        error "未找到可用的 Go 二进制"
    fi
}

# 列出远程可用版本
list_remote_versions() {
    info "正在获取可用版本列表..."
    
    if command -v curl >/dev/null 2>&1; then
        curl -L -s https://golang.org/VERSION?m=text 2>/dev/null | head -10 | while read -r version; do
            echo "$(echo "$version" | sed 's/^go//')"
        done
    else
        warn "需要 curl 来获取远程版本列表"
        info "访问 https://golang.org/dl/ 查看可用版本"
    fi
}

# 清理缓存
clean_cache() {
    info "正在清理 gow 缓存..."
    
    if [ -d "$GOW_CACHE_DIR" ]; then
        local cache_size=$(du -sh "$GOW_CACHE_DIR" 2>/dev/null | cut -f1)
        rm -rf "$GOW_CACHE_DIR"/*
        success "缓存已清理 (释放空间: $cache_size)"
    else
        info "缓存目录不存在"
    fi
    
    # 清理 Go 构建缓存
    local go_binary=$(get_go_binary)
    if [ -n "$go_binary" ] && [ -x "$go_binary" ]; then
        info "清理 Go 构建缓存..."
        "$go_binary" clean -cache 2>/dev/null || true
        "$go_binary" clean -modcache 2>/dev/null || true
    fi
}

# 确保使用正确的 Go 版本
ensure_go_version() {
    local go_binary=$(get_go_binary)
    if [ -z "$go_binary" ]; then
        error "未找到 Go，请安装 Go 或使用 'gow install <version>'"
        exit 1
    fi
    
    if [ ! -x "$go_binary" ]; then
        error "Go 二进制不可执行: $go_binary"
        exit 1
    fi
    
    # 设置环境变量
    local version_dir=$(dirname "$(dirname "$go_binary")")
    export GOROOT="$version_dir"
    
    # 确保 gow 的 Go bin 目录在 PATH 最前面
    export PATH="$version_dir/bin:$PATH"
    
    debug "使用 Go: $go_binary"
    debug "GOROOT: $GOROOT"
    debug "PATH: $PATH"
}

# 管理依赖
manage_deps() {
    ensure_go_version
    local go_binary=$(get_go_binary)
    
    case $1 in
        "update")
            info "更新依赖..."
            "$go_binary" get -u ./...
            "$go_binary" mod tidy
            ;;
        "vendor")
            info "创建 vendor 目录..."
            "$go_binary" mod vendor
            ;;
        "verify")
            info "验证依赖..."
            "$go_binary" mod verify
            ;;
        "download")
            info "下载依赖..."
            "$go_binary" mod download
            ;;
        "why")
            shift
            if [ $# -eq 0 ]; then
                error "请指定要查询的包"
                return 1
            fi
            info "查询依赖关系: $*"
            "$go_binary" mod why "$@"
            ;;
        "graph")
            info "显示依赖图..."
            "$go_binary" mod graph
            ;;
        *)
            echo "可用操作:"
            echo "  update    - 更新所有依赖"
            echo "  vendor    - 创建 vendor 目录"
            echo "  verify    - 验证依赖"
            echo "  download  - 下载依赖"
            echo "  why <pkg> - 查询为什么需要某个包"
            echo "  graph     - 显示依赖图"
            ;;
    esac
}

# 自我更新
self_update() {
    info "正在更新 gow..."
    
    local script_url="https://raw.githubusercontent.com/all3n/buildfly/main/gow"
    local current_script="$0"
    
    if command -v curl >/dev/null 2>&1; then
        local temp_file=$(mktemp)
        if curl -s -o "$temp_file" "$script_url"; then
            if [ -s "$temp_file" ]; then
                chmod +x "$temp_file"
                mv "$temp_file" "$current_script"
                success "gow 更新完成"
            else
                error "下载的文件为空"
                rm -f "$temp_file"
            fi
        else
            error "下载失败"
            rm -f "$temp_file"
        fi
    else
        error "需要 curl 来更新 gow"
    fi
}

# 主函数
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    case $1 in
        "help"|"-h"|"--help")
            show_help
            ;;
        "init")
            init_gow
            ;;
        "version"|"-v"|"--version")
            echo "Go Wrapper v$GOW_VERSION"
            local go_binary=$(get_go_binary)
            if [ -n "$go_binary" ] && [ -x "$go_binary" ]; then
                "$go_binary" version
            else
                echo "Go 未安装或不可用"
            fi
            ;;
        "current")
            local version=$(get_current_go_version)
            if [ -n "$version" ]; then
                echo "go$version"
            else
                echo "未设置 Go 版本"
            fi
            ;;
        "use")
            if [ $# -ne 2 ]; then
                error "用法: gow use <version>"
                exit 1
            fi
            use_go_version "$2"
            ;;
        "install")
            if [ $# -ne 2 ]; then
                error "用法: gow install <version>"
                exit 1
            fi
            install_go_version "$2"
            ;;
        "uninstall")
            if [ $# -ne 2 ]; then
                error "用法: gow uninstall <version>"
                exit 1
            fi
            uninstall_go_version "$2"
            ;;
        "list")
            echo "已安装的 Go 版本:"
            list_installed_versions | while read -r version; do
                local current=$(get_current_go_version)
                if [ "$version" = "go$current" ]; then
                    echo "  ✓ $version (当前)"
                else
                    echo "    $version"
                fi
            done
            ;;
        "list-remote")
            list_remote_versions
            ;;
        "doctor")
            doctor
            ;;
        "deps")
            manage_deps "${@:2}"
            ;;
        "clean")
            clean_cache
            ;;
        "self-update")
            self_update
            ;;
        "update")
            warn "'update' 命令已弃用，请使用 'self-update'"
            self_update
            ;;
        "build"|"run"|"test"|"mod")
            ensure_go_version
            local go_binary=$(get_go_binary)
            "$go_binary" "$@"
            ;;
        *)
            # 如果是文件，直接运行
            if [ -f "$1" ]; then
                ensure_go_version
                local go_binary=$(get_go_binary)
                "$go_binary" run "$@"
            else
                error "未知命令: $1"
                echo
                show_help
                exit 1
            fi
            ;;
    esac
}

# 运行主函数
main "$@"
